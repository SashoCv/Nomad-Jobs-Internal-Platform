<?php

namespace App\Http\Controllers;

use App\Models\AgentServiceContract;
use App\Models\AgentContractFile;
use App\Models\AgentContractPricing;
use App\Models\Permission;
use App\Traits\HasRolePermissions;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;

class AgentServiceContractController extends Controller
{
    use HasRolePermissions;

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function index()
    {
        try {
            if (!$this->checkPermission(Permission::AGENTS_CONTRACTS_READ)) {
                return response()->json(['error' => 'Insufficient permissions'], 403);
            }

            $user = Auth::user();
            $query = AgentServiceContract::with(['agent']);

            // If user is an agent, only show their own contracts
            if ($user->role_id === \App\Models\Role::AGENT) {
                $query->where('agent_id', $user->id);
            }

            $agentServiceContracts = $query->get()
                ->map(function ($contract) {
                    // Check if contract has a file
                    $hasFile = AgentContractFile::where('agent_service_contract_id', $contract->id)->exists();
                    $contract->hasContractFile = $hasFile;

                    // Check if contract has a pricelist
                    $hasPricelist = AgentContractPricing::where('agent_service_contract_id', $contract->id)->exists();
                    $contract->hasPricelist = $hasPricelist;

                    return $contract;
                });

            return response()->json($agentServiceContracts);
        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to retrieve contracts: ' . $e->getMessage()], 500);
        }
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function store(Request $request)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::AGENTS_CONTRACTS_CREATE)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $request->validate([
                'agent_id' => 'required|exists:users,id',
                'status' => 'required|in:' . implode(',', [
                        AgentServiceContract::STATUS_PENDING,
                        AgentServiceContract::STATUS_ACTIVE,
                        AgentServiceContract::STATUS_EXPIRED,
                        AgentServiceContract::STATUS_TERMINATED
                    ]),
                'startDate' => 'nullable|date',
                'endDate' => 'nullable|date|after_or_equal:startDate',
            ]);

            // If creating an active contract, first check if one already exists
            if ($request->status === AgentServiceContract::STATUS_ACTIVE) {
                $existingActiveContract = AgentServiceContract::where('agent_id', $request->agent_id)
                    ->where('status', AgentServiceContract::STATUS_ACTIVE)
                    ->first();

                if ($existingActiveContract) {
                    return response()->json([
                        'error' => 'Този агент вече има активен договор (№' . $existingActiveContract->contractNumber . '). Моля, първо деактивирайте съществуващия договор.'
                    ], 422);
                }
            }

            // Create contract without contractNumber - it will be auto-generated by model
            $agentServiceContract = new AgentServiceContract($request->except('contractNumber'));
            $agentServiceContract->save();

            return response()->json($agentServiceContract, 201);
        } catch (\Illuminate\Database\QueryException $e) {
            if ($e->getCode() === '23000') {
                return response()->json([
                    'error' => 'Този агент вече има активен договор. Моля, първо деактивирайте съществуващия договор.'
                ], 422);
            }
            return response()->json(['error' => 'Failed to create contract: ' . $e->getMessage()], 400);
        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to create contract: ' . $e->getMessage()], 400);
        }
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\JsonResponse
     */
    public function show($id)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::AGENTS_CONTRACTS_READ)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $agentServiceContract = AgentServiceContract::with(['agent'])->findOrFail($id);

            return response()->json($agentServiceContract);
        } catch (\Exception $e) {
            return response()->json(['error' => 'Contract not found'], 404);
        }
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\JsonResponse
     */
    public function update(Request $request, $id)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::AGENTS_CONTRACTS_UPDATE)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $request->validate([
                'agent_id' => 'required|exists:users,id',
                'status' => 'required|in:' . implode(',', [
                        AgentServiceContract::STATUS_PENDING,
                        AgentServiceContract::STATUS_ACTIVE,
                        AgentServiceContract::STATUS_EXPIRED,
                        AgentServiceContract::STATUS_TERMINATED
                    ]),
                'startDate' => 'nullable|date',
                'endDate' => 'nullable|date|after_or_equal:startDate',
            ]);

            $agentServiceContract = AgentServiceContract::findOrFail($id);
            $previousStatus = $agentServiceContract->status;

            // Update without contractNumber - it's auto-generated and shouldn't be changed
            $agentServiceContract->fill($request->except('contractNumber'));
            $agentServiceContract->save();

            // If updating to active status, use the helper method to handle deactivation
            if ($request->status === AgentServiceContract::STATUS_ACTIVE &&
                $previousStatus !== AgentServiceContract::STATUS_ACTIVE) {
                $agentServiceContract->setAsActive();
            }

            return response()->json($agentServiceContract, 200);

        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to update contract: ' . $e->getMessage()], 400);
        }
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\JsonResponse
     */
    public function destroy($id)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::AGENTS_CONTRACTS_DELETE)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $agentServiceContract = AgentServiceContract::findOrFail($id);

            // Delete associated files
            $contractFiles = AgentContractFile::where('agent_service_contract_id', $id)->get();
            if ($contractFiles->isNotEmpty()) {
                foreach ($contractFiles as $file) {
                    Storage::disk('public')->delete($file->filePath);
                    $file->delete();
                }
            }

            $agentServiceContract->delete();

            return response()->json(['message' => 'Contract deleted successfully'], 200);

        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to delete contract: ' . $e->getMessage()], 500);
        }
    }

    /**
     * Upload contract file for agent
     *
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function storeContractFileForAgent(Request $request)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::DOCUMENTS_CREATE)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $request->validate([
                'agent_service_contract_id' => 'required|exists:agent_service_contracts,id',
                'file' => 'required|file|mimes:pdf,doc,docx,jpg,jpeg,png|max:10240', // 10MB max
            ]);

            $file = $request->file('file');
            $filePath = Storage::disk('public')->put('agent_contract_files', $file);

            $agentContractFile = new AgentContractFile();
            $agentContractFile->agent_service_contract_id = $request->agent_service_contract_id;
            $agentContractFile->filePath = $filePath;
            $agentContractFile->fileName = $file->getClientOriginalName();
            $agentContractFile->save();

            return response()->json([
                'message' => 'Contract file stored successfully',
                'file' => $agentContractFile
            ], 201);

        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to store contract file: ' . $e->getMessage()], 500);
        }
    }

    /**
     * Download contract file for agent
     *
     * @param int $contractId
     * @return \Illuminate\Http\Response
     */
    public function downloadContractFile($contractId)
    {
        try {
            $contractFile = AgentContractFile::where('agent_service_contract_id', $contractId)
                ->firstOrFail();

            $filePath = storage_path('app/public/' . $contractFile->filePath);

            if (!file_exists($filePath)) {
                return response()->json(['error' => 'File not found'], 404);
            }

            // Get agent name
            $contract = AgentServiceContract::with('agent')->findOrFail($contractFile->agent_service_contract_id);
            $agentName = $contract->agent->firstName . '_' . $contract->agent->lastName;

            // Get file extension
            $extension = pathinfo($filePath, PATHINFO_EXTENSION);

            // Build filename: contract_file_AgentName.extension
            $fileName = 'contract_file_' . $agentName . '.' . $extension;

            return response()->download($filePath, $fileName);

        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to download contract file: ' . $e->getMessage()], 500);
        }
    }

    /**
     * Delete contract file for agent
     *
     * @param int $contractId
     * @return \Illuminate\Http\JsonResponse
     */
    public function deleteContractFile($contractId)
    {
        try {
            // TODO: Add permission check later
            // if (!$this->checkPermission(Permission::DOCUMENTS_DELETE)) {
            //     return response()->json(['error' => 'Insufficient permissions'], 403);
            // }

            $contractFile = AgentContractFile::where('agent_service_contract_id', $contractId)
                ->firstOrFail();

            // Delete file from storage
            Storage::disk('public')->delete($contractFile->filePath);

            // Delete database record
            $contractFile->delete();

            return response()->json(['message' => 'Contract file deleted successfully'], 200);

        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to delete contract file: ' . $e->getMessage()], 500);
        }
    }
}
