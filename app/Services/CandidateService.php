<?php

namespace App\Services;

use App\Jobs\SendEmailForArrivalStatusCandidates;
use App\Models\AgentCandidate;
use App\Models\CalendarEvent;
use App\Models\Candidate;
use App\Models\CandidatePassport;
use App\Models\Category;
use App\Models\CompanyJob;
use App\Models\File;
use App\Models\Position;
use App\Models\Statushistory;
use Carbon\Carbon;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;

class CandidateService
{
    public function createCandidate($data): Candidate
    {
        return DB::transaction(function () use ($data) {
            $candidate = new Candidate();
            $data['user_id'] = is_numeric($data['user_id']) ? (int) $data['user_id'] : null;

            // Convert string 'false'/'true' to boolean for has_driving_license
            if (isset($data['has_driving_license'])) {
                $data['has_driving_license'] = filter_var($data['has_driving_license'], FILTER_VALIDATE_BOOLEAN);
            }

            $candidate->fill($data);

            $candidate->addedBy = Auth::id();
            $statusId = $data['status_id'] ?? 16; // Default to 'New' status if not provided


            // Calculate derived fields

            $candidate->quartal = $candidate->calculateQuartal(Carbon::parse($data['date']));

            if ($data['contractType'] === Candidate::CONTRACT_TYPE_90_DAYS) {
                $candidate->seasonal = $candidate->calculateSeason(Carbon::parse($data['date']));
            }

            if (isset($data['contractPeriod'])) {
                $candidate->contractPeriodDate = $candidate->calculateContractEndDate(
                    Carbon::parse($data['date']),
                    $data['contractPeriod']
                );
            }

            $candidate->save();

            // Create calendar event for contract expiry if endContractDate is set
            if (!empty($candidate->endContractDate)) {
                CalendarEvent::updateOrCreate(
                    [
                        'type' => CalendarEvent::TYPE_CONTRACT_EXPIRY,
                        'candidate_id' => $candidate->id,
                    ],
                    [
                        'title' => 'Изтичащ договор',
                        'date' => $candidate->endContractDate,
                        'company_id' => $candidate->company_id,
                        'created_by' => Auth::id(),
                    ]
                );
            }

            $statusHistory = [
                'candidate_id' => $candidate->id,
                'status_id' => $statusId,
                'statusDate' => Carbon::now()->toDateString(),
                'description' => 'Candidate created',
            ];

            $candidate->statusHistories()->create($statusHistory);
            dispatch(new SendEmailForArrivalStatusCandidates($statusId, $candidate->id, Carbon::now()->toDateString(), false));

            // Handle file uploads
            $this->handleFileUploads($candidate, $data);

            // Create default category

            $this->createDefaultCategory($candidate);

            // Create agent_candidates record if agent_id and company_job_id are provided
            if (!empty($data['agent_id']) && !empty($data['company_job_id'])) {
                AgentCandidate::create([
                    'user_id' => $data['agent_id'],
                    'company_job_id' => $data['company_job_id'],
                    'candidate_id' => $candidate->id,
                    'status_for_candidate_from_agent_id' => 3, // Approved status
                    'nomad_office_id' => Auth::user()->id ?? null, // Can be set based on your business logic
                ]);

                // Check if job posting should be marked as "filled"
                $this->checkAndUpdateJobFilledStatus($data['company_job_id']);
            }

            return $candidate;
        });
    }

    public function updateCandidate(Candidate $candidate, $data): Candidate
    {
        return DB::transaction(function () use ($candidate, $data) {
            // Clean up auto-generated files
            $this->cleanupAutoGeneratedFiles($candidate);

            // Convert string 'false'/'true' to boolean for has_driving_license
            if (isset($data['has_driving_license'])) {
                $data['has_driving_license'] = filter_var($data['has_driving_license'], FILTER_VALIDATE_BOOLEAN);
            }

            $candidate->fill($data);


            // Recalculate derived fields
            $candidate->quartal = $candidate->calculateQuartal(Carbon::parse($data['date']));

            if ($data['contractType'] === Candidate::CONTRACT_TYPE_90_DAYS) {
                $candidate->seasonal = $candidate->calculateSeason(Carbon::parse($data['date']));
                Log::info("Candidate seasonal status updated to: {$candidate->seasonal}");
            } else {
                $candidate->seasonal = null;
            }

            if (isset($data['contractPeriod'])) {
                $candidate->contractPeriodDate = $candidate->calculateContractEndDate(
                    Carbon::parse($data['date']),
                    $data['contractPeriod']
                );
            }

            $candidate->save();

            // Create/update calendar event for contract expiry if endContractDate is set
            if (!empty($candidate->endContractDate)) {
                CalendarEvent::updateOrCreate(
                    [
                        'type' => CalendarEvent::TYPE_CONTRACT_EXPIRY,
                        'candidate_id' => $candidate->id,
                    ],
                    [
                        'title' => 'Изтичащ договор',
                        'date' => $candidate->endContractDate,
                        'company_id' => $candidate->company_id,
                    ]
                );
            }

            // Handle file uploads
            $this->handleFileUploads($candidate, $data);

            // Handle agent_candidates record
            $existingAgentCandidate = AgentCandidate::where('candidate_id', $candidate->id)->first();

            if (!empty($data['agent_id']) && !empty($data['company_job_id'])) {
                // If both agent_id and company_job_id are provided, create or update the record
                if ($existingAgentCandidate) {
                    // Update existing record
                    $existingAgentCandidate->update([
                        'user_id' => $data['agent_id'],
                        'company_job_id' => $data['company_job_id'],
                        'status_for_candidate_from_agent_id' => 3, // Keep approved status
                    ]);
                } else {
                    // Create new record
                    AgentCandidate::create([
                        'user_id' => $data['agent_id'],
                        'company_job_id' => $data['company_job_id'],
                        'candidate_id' => $candidate->id,
                        'status_for_candidate_from_agent_id' => 3, // Approved status
                        'nomad_office_id' => Auth::user()->id ?? null,
                    ]);
                }

                // Check if job posting should be marked as "filled"
                $this->checkAndUpdateJobFilledStatus($data['company_job_id']);
            } elseif ($existingAgentCandidate) {
                // If agent_id or company_job_id is not provided, delete the existing record
                $existingAgentCandidate->delete();
            }

            return $candidate->load('position');
        });
    }

    public function extendCandidateContract(Candidate $originalCandidate, array $data): Candidate
    {
        return DB::transaction(function () use ($originalCandidate, $data) {
            $newCandidate = $originalCandidate->replicate();
            $newCandidate->contractPeriodNumber = ($originalCandidate->contractPeriodNumber ?? 0) + 1;
            $newCandidate->fill($data);

            // Calculate derived fields
            $newCandidate->quartal = $newCandidate->calculateQuartal(Carbon::parse($data['date']));

            if ($data['contractType'] === Candidate::CONTRACT_TYPE_90_DAYS) {
                $newCandidate->seasonal = $newCandidate->calculateSeason(Carbon::parse($data['date']));
            }

            if (isset($data['contractPeriod'])) {
                $newCandidate->contractPeriodDate = $newCandidate->calculateContractEndDate(
                    Carbon::parse($data['date']),
                    $data['contractPeriod']
                );
            }

            $newCandidate->save();

            // Handle file uploads
            $this->handleFileUploads($newCandidate, $data);

            return $newCandidate->load('position');
        });
    }

    public function promoteToEmployee(Candidate $candidate): bool
    {
        $candidate->promoteToEmployee();
        return true;
    }

    public function deleteCandidate(Candidate $candidate): bool
    {
        return DB::transaction(function () use ($candidate) {
            $userId = Auth::id();

            // Delete associated files
            $files = File::where('candidate_id', $candidate->id)->get();

            foreach ($files as $file) {
                if ($file->filePath && Storage::disk('public')->exists($file->filePath)) {
                    Storage::disk('public')->delete($file->filePath);
                }
                $file->delete();
            }

            // Delete categories
            Category::where('candidate_id', $candidate->id)->delete();

            // Set deleted_by on agent_candidates if exists
            $agentCandidate = AgentCandidate::where('candidate_id', $candidate->id)->first();
            if ($agentCandidate) {
                $agentCandidate->deleted_by = $userId;
                $agentCandidate->save();
                $agentCandidate->delete();
            }

            // Set deleted_by before soft delete
            $candidate->deleted_by = $userId;
            $candidate->save();

            return $candidate->delete();
        });
    }

    public function updateSeasonalForAllCandidates(): int
    {
        $candidates = Candidate::seasonalContracts()->get();
        $updated = 0;

        foreach ($candidates as $candidate) {
            if ($candidate->date) {
                $candidate->seasonal = $candidate->calculateSeason($candidate->date);
                $candidate->save();
                $updated++;
            }
        }

        return $updated;
    }

    public function updateQuartalForAllCandidates(): int
    {
        $candidates = Candidate::all();
        $updated = 0;

        foreach ($candidates as $candidate) {
            if ($candidate->date) {
                $candidate->quartal = $candidate->calculateQuartal($candidate->date);
                $candidate->save();
                $updated++;
            }
        }

        return $updated;
    }

    public function updateAddedByForAllCandidates(): int
    {
        $candidates = Candidate::whereNull('addedBy')->get();
        $updated = 0;

        foreach ($candidates as $candidate) {
            $candidate->addedBy = $candidate->user_id ?? 11; // Default admin user
            $candidate->save();
            $updated++;
        }

        return $updated;
    }

    public function getExpiringContracts(int $monthsAhead = 4): \Illuminate\Database\Eloquent\Builder
    {
        $futureDate = Carbon::now()->addMonths($monthsAhead);

        return Candidate::with(['company:id,nameOfCompany,EIK', 'status:id,nameOfStatus', 'position:id,jobPosition'])
            ->contractExpiring($futureDate)
            ->orderBy('endContractDate', 'asc');
    }

    public function getFirstQuartal(): ?string
    {
        $candidate = Candidate::whereNotNull('quartal')
            ->orderByRaw('CAST(SUBSTRING_INDEX(quartal, "/", -1) AS UNSIGNED)')
            ->orderByRaw('CAST(SUBSTRING_INDEX(quartal, "/", 1) AS UNSIGNED)')
            ->first();

        return $candidate?->quartal;
    }

    protected function handleFileUploads(Candidate $candidate, array $data): void
    {
        // Handle passport - always sync to candidate_passports table
        $this->syncPassportData($candidate, $data);

        // Handle profile picture
        if (isset($data['personPicture'])
            && $data['personPicture'] instanceof UploadedFile
            && $data['personPicture']->isValid()
            && $data['personPicture']->getSize() > 0
        ) {
            $picturePath = $data['personPicture']->store('personImages', 'public');
            $candidate->update([
                'personPicturePath' => $picturePath,
                'personPictureName' => $data['personPicture']->getClientOriginalName()
            ]);
        }
    }

    /**
     * Sync passport data to candidate_passports table.
     * Handles both file uploads and text field updates.
     * Implements DUAL WRITE for backward compatibility with legacy columns.
     */
    protected function syncPassportData(Candidate $candidate, array $data): void
    {
        $passportPath = null;
        $passportFileName = null;

        // Handle file upload if present
        if (isset($data['personPassport'])
            && $data['personPassport'] instanceof UploadedFile
            && $data['personPassport']->isValid()
            && $data['personPassport']->getSize() > 0
        ) {
            // Store file in organized directory structure
            $directory = 'candidate/' . $candidate->id . '/passport';
            $fileName = \Illuminate\Support\Str::uuid() . '_' . $data['personPassport']->getClientOriginalName();
            $passportPath = $data['personPassport']->storeAs($directory, $fileName, 'public');
            $passportFileName = $data['personPassport']->getClientOriginalName();

            // Update legacy fields for backward compatibility
            $candidate->update([
                'passportPath' => $passportPath,
                'passportName' => $passportFileName
            ]);
        }

        // Check if we have any passport data to sync
        $hasPassportData = !empty($data['passport'])
            || !empty($data['passportValidUntil'])
            || !empty($data['passportIssuedOn'])
            || !empty($data['passportIssuedBy'])
            || $passportPath !== null;

        if (!$hasPassportData) {
            return;
        }

        // Build update data - only include fields that are present in the request
        $passportData = [
            'candidate_id' => $candidate->id,
        ];

        // Always sync these fields if present in request
        if (array_key_exists('passport', $data)) {
            $passportData['passport_number'] = $data['passport'];
        }
        if (array_key_exists('passportValidUntil', $data)) {
            $passportData['expiry_date'] = $data['passportValidUntil'];
        }
        if (array_key_exists('passportIssuedOn', $data)) {
            $passportData['issue_date'] = $data['passportIssuedOn'];
        }
        if (array_key_exists('passportIssuedBy', $data)) {
            $passportData['issued_by'] = $data['passportIssuedBy'];
        }

        // Add file data if uploaded
        if ($passportPath !== null) {
            $passportData['file_path'] = $passportPath;
            $passportData['file_name'] = $passportFileName;
        }

        // Create or update passport record
        CandidatePassport::updateOrCreate(
            ['candidate_id' => $candidate->id],
            $passportData
        );

        Log::info('Synced passport data to candidate_passports', [
            'candidate_id' => $candidate->id,
            'has_file' => $passportPath !== null,
        ]);
    }



    protected function createDefaultCategory(Candidate $candidate): void
    {
        foreach (\App\Enums\DefaultCandidateCategory::cases() as $category) {
            $def = $category->definition();
            
            Category::create([
                'candidate_id' => $candidate->id,
                'nameOfCategory' => $def->name,
                'description'   => $def->description,
                'role_id'       => $def->roleId,
                'isGenerated'   => $def->isGenerated,
            ]);
        }
    }

    protected function cleanupAutoGeneratedFiles(Candidate $candidate): void
    {
        $files = File::where('candidate_id', $candidate->id)
            ->where('autoGenerated', 1)
            ->where('deleteFile', 0)
            ->get();

        foreach ($files as $file) {
            if ($file->filePath && Storage::disk('public')->exists($file->filePath)) {
                Storage::disk('public')->delete($file->filePath);
            }
            $file->delete();
        }
    }

    /**
     * Check if a job posting should be marked as "filled" based on approved candidates count.
     */
    protected function checkAndUpdateJobFilledStatus(int $companyJobId): void
    {
        $companyJob = CompanyJob::find($companyJobId);

        if (!$companyJob || !in_array($companyJob->status, ['active', 'inactive'])) {
            return;
        }

        // Count approved candidates (status_for_candidate_from_agent_id = 3)
        $approvedCount = AgentCandidate::where('company_job_id', $companyJobId)
            ->where('status_for_candidate_from_agent_id', 3)
            ->whereNull('deleted_at')
            ->count();

        // If approved candidates reach or exceed the number of positions, mark as filled
        if ($approvedCount >= $companyJob->number_of_positions) {
            $companyJob->status = 'filled';
            $companyJob->save();
        }
    }
}
